@page "/article/new"
@page "/article/{id:guid}/edit"
@using Wave.Data
@using Microsoft.EntityFrameworkCore
@using System.ComponentModel.DataAnnotations
@using Microsoft.AspNetCore.Identity
@using Wave.Utilities

@rendermode InteractiveServer
@attribute [Authorize(Policy = "ArticleEditOrReviewPermissions")]
@inject IDbContextFactory<ApplicationDbContext> ContextFactory
@inject NavigationManager Navigation
@inject UserManager<ApplicationUser> UserManager
@inject IStringLocalizer<ArticleEditor> Localizer

@if (Article is not null) {
    <PageTitle>@(TitlePrefix + Localizer["PageTitle_Edit"]) | @Article.Title</PageTitle>
} else {
    <PageTitle>@(TitlePrefix + Localizer["PageTitle_New"])</PageTitle>
}

<h1 class="text-3xl lg:text-5xl font-light mb-6">@Localizer["EditorTitle"]</h1>

<div>
    <ul class="steps">
        <li class="step @(Article?.Status >= ArticleStatus.Draft ? "step-primary": "")">@Localizer["Draft"]</li>
        <li class="step @(Article?.Status >= ArticleStatus.InReview ? "step-primary": "")">@Localizer["InReview"]</li>
        <li class="step @(Article?.Status >= ArticleStatus.Published ? "step-primary": "")">@Localizer["Published"]</li>
    </ul>
</div>

<EditForm method="post" FormName="article-editor" Model="@Model" OnValidSubmit="OnValidSubmit">
    <DataAnnotationsValidator />
    <input type="hidden" @bind-value="@Model.Id"/>
    
    <InputLabelComponent LabelText="@Localizer["Title_Label"]" For="() => Model.Title">
        <InputText class="input input-bordered w-full" maxlength="256" required aria-required disabled="@CannotEdit"
                   @bind-Value="@Model.Title" placeholder="@Localizer["Title_Placeholder"]" autocomplete="off" />
    </InputLabelComponent>
    <InputLabelComponent LabelText="@Localizer["PublishDate_Label"]" For="() => Model.PublishDate">
        @if (Article?.Status is null or ArticleStatus.Draft) {
            <InputDate class="input input-bordered w-full" disabled="@CannotEdit" Type="InputDateType.DateTimeLocal"
                       @bind-Value="@Model.PublishDate" placeholder="@Localizer["PublishDate_Placeholder"]" autocomplete="off" />
        } else {
            <input class="input input-bordered w-full" 
                   type="datetime-local" readonly value="@Article?.PublishDate.ToString("yyyy-MM-dd\\THH:mm:ss")" />
        }
    </InputLabelComponent>

    <AdvancedMarkdownEditor Title="@Model.Title" MarkdownCallback="() => Model.Body">
        <InputLabelComponent LabelText="@Localizer["Body_Label"]" For="() => Model.Body">
            <textarea class="textarea textarea-bordered w-full min-h-96 h-full" required aria-required disabled="@CannotEdit"
                      @bind="@Model.Body" @bind:event="oninput" placeholder="@Localizer["Body_Placeholder"]" autocomplete="off"></textarea>
        </InputLabelComponent>
    </AdvancedMarkdownEditor>
    
    <div class="flex gap-2 flex-wrap mt-3">
        <button type="submit" class="btn btn-primary w-full sm:btn-wide" disabled="@CannotEdit">
            @Localizer["EditorSubmit"]
        </button>
        @if (Article is not null) {
            <a class="btn w-full sm:btn-wide" href="/article/@(Article.Id)">
                @Localizer["ViewArticle_Label"]
            </a>
        }
    </div>
</EditForm>

@code {
	[CascadingParameter(Name = "TitlePrefix")]
	private string TitlePrefix { get; set; } = default!;

    [Parameter]
    public Guid? Id { get; set; }
    [SupplyParameterFromForm]
    private InputModel Model { get; set; } = null!;
    
    [CascadingParameter]
    private Task<AuthenticationState>? AuthenticationState { get; set; }

    private ApplicationUser User { get; set; } = null!;
    private bool IsAdmin { get; set; }
    private Article? Article { get; set; } 
    private MarkupString? Content => Article is null ? null : new MarkupString(Article.BodyHtml);
    private bool CannotEdit => User is null || !IsAdmin && Article is not null && Article.Author.Id != User.Id;

    protected override async Task OnInitializedAsync() {
        if (Id is not null) {
            // We need blocking calls here, bc otherwise Blazor will execute Render in parallel,
            // running into a null pointer on the Article property and panicking

            // ReSharper disable once MethodHasAsyncOverload
            await using var context = ContextFactory.CreateDbContext();
            // ReSharper disable once MethodHasAsyncOverload
            Article = context.Set<Article>()
                .Include(a => a.Author)
                .Include(a => a.Reviewer)
                .First(a => a.Id == Id);

            if (Article is null) throw new ApplicationException("Article not found.");
        }

        // ReSharper disable once NullCoalescingConditionIsAlwaysNotNullAccordingToAPIContract
        Model ??= new InputModel();
        Model.Id ??= Article?.Id;
        Model.Title ??= Article?.Title;
        Model.Body ??= Article?.Body;
        Model.PublishDate ??= Article?.PublishDate.LocalDateTime;
        
        if (AuthenticationState is null) throw new ApplicationException("???");
        var state = await AuthenticationState;
        var user = await UserManager.GetUserAsync(state.User);
        User = user ?? throw new ApplicationException("???2");
        IsAdmin = await UserManager.IsInRoleAsync(User, "Admin");

        // TODO properly check if user can edit this article (see HandleRoles)
    }

    private async Task OnValidSubmit() {
        await using var context = await ContextFactory.CreateDbContextAsync();
        context.Entry(User).State = EntityState.Unchanged;

        Article article;
        if (Model.Id is not null) {
            article = await context.Set<Article>()
                .Include(a => a.Author)
                .Include(a => a.Reviewer)
                .FirstAsync(a => a.Id == Model.Id);
            article.Title = Model.Title!;
            article.Body = Model.Body!;
        } else {
            article = new Article {
                Title = Model.Title!,
                Body = Model.Body!,
                Author = User
            };
            await context.AddAsync(article);
        }
        if (Model.PublishDate is not null) article.PublishDate = Model.PublishDate.Value;

        article.LastModified = DateTimeOffset.UtcNow;
        HandleRoles(article, User);

        article.BodyHtml = MarkdownUtilities.Parse(article.Body);
        
        await context.SaveChangesAsync();
        if (article.Status >= ArticleStatus.Published &&  article.PublishDate <= DateTimeOffset.UtcNow) {
            Navigation.NavigateTo($"/article/{article.Id}");
        } else {
            Navigation.NavigateTo($"/article/{article.Id}/edit");
        }
    }

    private async Task HandleRoles(Article article, ApplicationUser me) {
        // it's our draft
        if (article.Status is ArticleStatus.Draft && article.Author.Id == me.Id) return;

        var roles = await UserManager.GetRolesAsync(me);

        // reviewers and admins can review articles
        if (article.Status is ArticleStatus.InReview && roles.Any(r => r is "Admin" or "Reviewer")) {
            article.Reviewer = me;
            return;
        }

        // published articles may only be edited my admins or moderators 
        if (article.Status is ArticleStatus.Published && roles.Any(r => r is "Admin" or "Reviewer")) {
            article.Reviewer = me; // TODO replace with editor or something?
            return;
        }

        throw new ApplicationException("You do not have permissions to edit this article");
    }

    private sealed class InputModel {
        public Guid? Id { get; set; }
        [Required(AllowEmptyStrings = false), MaxLength(256)]
        public string? Title { get; set; }
        [Required(AllowEmptyStrings = false)]
        public string? Body { get; set; }

        public DateTimeOffset? PublishDate { get; set; }
    }
}
